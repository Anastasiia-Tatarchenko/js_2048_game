{"version":3,"sources":["modules/Game.class.js","scripts/main.js"],"names":["Game","initialState","length","every","row","Error","restart","status","result","moveTiles","isStateDifferent","state","updateGame","score","putNewNumber","cloneState","firstMoveMade","newState","push","column","isGameOver","isGameWon","reduce","space","rowIndex","forEach","cell","cellIndex","x","y","Math","floor","random","availableSpace","getAvailableSpace","randomSpace","getRandomElement","generateNumber","some","horizontal","firstCoord","position","forward","addScore","firstCoordLength","secondCoordLength","initialSecondCoord","startOfStripe","endOfStirpe","step","rowLength","columnLength","mergedInStripe","Array","fill","secondCoord","merged","currentCellCoords","getCellCoords","nextCellCoords","module","exports","require","game","updateTable","document","querySelectorAll","rowElement","cellState","columnIndex","cellElement","children","className","innerText","classList","add","setTimeout","remove","updateScore","querySelector","updateButton","button","updateMessage","gameStatus","message","messageClass","idle","win","lose","update","getState","getScore","getFirstMoveMade","getStatus","addEventListener","start","e","actions","action","ArrowUp","moveUp","ArrowRight","moveRight","ArrowDown","moveDown","ArrowLeft","moveLeft","key","preventDefault"],"mappings":"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","file":"main.74ed5613.js","sourceRoot":"../src","sourcesContent":["'use strict';\n\nclass Game {\n  constructor(\n    initialState = [\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n    ],\n  ) {\n    if (\n      initialState.length === 4 &&\n      initialState.every((row) => row.length === 4)\n    ) {\n      this.initialState = initialState;\n      this.restart();\n    } else {\n      throw new Error('Initial state is not valid!');\n    }\n  }\n\n  moveLeft() {\n    if (this.status === 'playing') {\n      const result = this.moveTiles(true, false);\n\n      if (this.isStateDifferent(result.state)) {\n        this.updateGame(result);\n      }\n    }\n  }\n\n  moveRight() {\n    if (this.status === 'playing') {\n      const result = this.moveTiles(true, true);\n\n      if (this.isStateDifferent(result.state)) {\n        this.updateGame(result);\n      }\n    }\n  }\n\n  moveUp() {\n    if (this.status === 'playing') {\n      const result = this.moveTiles(false, false);\n\n      if (this.isStateDifferent(result.state)) {\n        this.updateGame(result);\n      }\n    }\n  }\n\n  moveDown() {\n    if (this.status === 'playing') {\n      const result = this.moveTiles(false, true);\n\n      if (this.isStateDifferent(result.state)) {\n        this.updateGame(result);\n      }\n    }\n  }\n\n  getScore() {\n    return this.score;\n  }\n\n  getState() {\n    return this.state;\n  }\n\n  getStatus() {\n    return this.status;\n  }\n\n  start() {\n    this.restart();\n    this.status = 'playing';\n\n    this.putNewNumber();\n    this.putNewNumber();\n  }\n\n  restart() {\n    this.state = this.cloneState(this.initialState);\n    this.score = 0;\n    this.status = 'idle';\n    this.firstMoveMade = false;\n  }\n\n  cloneState(state) {\n    const newState = [];\n\n    for (let row = 0; row < state.length; row++) {\n      newState.push([...state[row]]);\n    }\n\n    return newState;\n  }\n\n  isStateDifferent(newState) {\n    for (let row = 0; row < this.state.length; row++) {\n      for (let column = 0; column < this.state[row].length; column++) {\n        if (this.state[row][column] !== newState[row][column]) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  updateGame(result) {\n    this.state = result.state;\n    this.score += result.score;\n    this.firstMoveMade = true;\n    this.putNewNumber();\n\n    if (this.isGameOver()) {\n      this.status = 'lose';\n    } else if (this.isGameWon()) {\n      this.status = 'win';\n    }\n  }\n\n  getFirstMoveMade() {\n    return this.firstMoveMade;\n  }\n\n  getAvailableSpace() {\n    return this.state.reduce((space, row, rowIndex) => {\n      row.forEach((cell, cellIndex) => {\n        if (cell === 0) {\n          space.push({\n            x: cellIndex,\n            y: rowIndex,\n          });\n        }\n      });\n\n      return space;\n    }, []);\n  }\n\n  getRandomElement(space) {\n    return space[Math.floor(Math.random() * space.length)];\n  }\n\n  generateNumber() {\n    return Math.floor(Math.random() * 10) === 0 ? 4 : 2;\n  }\n\n  putNewNumber() {\n    const availableSpace = this.getAvailableSpace();\n    const randomSpace = this.getRandomElement(availableSpace);\n\n    this.state[randomSpace.y][randomSpace.x] = this.generateNumber();\n  }\n\n  isGameOver() {\n    if (this.getAvailableSpace().length === 0) {\n      if (\n        this.isStateDifferent(this.moveTiles(false, false).state) ||\n        this.isStateDifferent(this.moveTiles(true, true).state) ||\n        this.isStateDifferent(this.moveTiles(false, true).state) ||\n        this.isStateDifferent(this.moveTiles(true, false).state)\n      ) {\n        return false;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  isGameWon() {\n    return this.state.some((row) => row.some((cell) => cell === 2048));\n  }\n\n  getCellCoords(horizontal, firstCoord, position) {\n    if (horizontal) {\n      return {\n        row: firstCoord,\n        column: position,\n      };\n    }\n\n    return {\n      row: position,\n      column: firstCoord,\n    };\n  }\n\n  moveTiles(horizontal, forward, addScore) {\n    const state = this.cloneState(this.state);\n    let score = 0;\n\n    const rowLength = state[0].length;\n    const columnLength = state.length;\n    let firstCoordLength;\n    let secondCoordLength;\n\n    if (horizontal) {\n      firstCoordLength = columnLength;\n      secondCoordLength = rowLength;\n    } else {\n      firstCoordLength = rowLength;\n      secondCoordLength = columnLength;\n    }\n\n    let initialSecondCoord;\n    let startOfStripe;\n    let endOfStirpe;\n    let step;\n\n    if (forward) {\n      initialSecondCoord = secondCoordLength - 2;\n      startOfStripe = -1;\n      endOfStirpe = secondCoordLength;\n      step = 1;\n    } else {\n      initialSecondCoord = 1;\n      startOfStripe = secondCoordLength;\n      endOfStirpe = -1;\n      step = -1;\n    }\n\n    for (let firstCoord = 0; firstCoord < firstCoordLength; firstCoord++) {\n      const mergedInStripe = Array(secondCoordLength).fill(false);\n\n      for (\n        let secondCoord = initialSecondCoord;\n        secondCoord !== startOfStripe;\n        secondCoord -= step\n      ) {\n        let merged = false;\n        let position = secondCoord;\n\n        let currentCellCoords = this.getCellCoords(\n          horizontal,\n          firstCoord,\n          position,\n        );\n        let nextCellCoords = this.getCellCoords(\n          horizontal,\n          firstCoord,\n          position + step,\n        );\n\n        while (\n          position + step !== endOfStirpe &&\n          (state[nextCellCoords.row][nextCellCoords.column] === 0 ||\n            (state[nextCellCoords.row][nextCellCoords.column] ===\n              state[currentCellCoords.row][currentCellCoords.column] &&\n              !mergedInStripe[position + step] &&\n              !merged))\n        ) {\n          if (state[nextCellCoords.row][nextCellCoords.column] > 0) {\n            merged = true;\n            score += state[nextCellCoords.row][nextCellCoords.column] * 2;\n          }\n\n          state[nextCellCoords.row][nextCellCoords.column] +=\n            state[currentCellCoords.row][currentCellCoords.column];\n          state[currentCellCoords.row][currentCellCoords.column] = 0;\n          position += step;\n\n          currentCellCoords = this.getCellCoords(\n            horizontal,\n            firstCoord,\n            position,\n          );\n\n          nextCellCoords = this.getCellCoords(\n            horizontal,\n            firstCoord,\n            position + step,\n          );\n        }\n\n        if (merged) {\n          mergedInStripe[position] = true;\n        }\n      }\n    }\n\n    return {\n      state: state,\n      score: score,\n    };\n  }\n}\n\nmodule.exports = Game;\n\n// 'use strict';\n\n// /**\n//  * This class represents the game.\n//  * Now it has a basic structure, that is needed for testing.\n//  * Feel free to add more props and methods if needed.\n//  */\n// class Game {\n//   /**\n//    * Creates a new game instance.\n//    *\n//    * @param {number[][]} initialState\n//    * The initial state of the board.\n//    * @default\n//    * [[0, 0, 0, 0],\n//    *  [0, 0, 0, 0],\n//    *  [0, 0, 0, 0],\n//    *  [0, 0, 0, 0]]\n//    *\n//    * If passed, the board will be initialized with the provided\n//    * initial state.\n//    */\n\n//   constructor(\n//     initialState = [\n//       [0, 0, 0, 0],\n//       [0, 0, 0, 0],\n//       [0, 0, 0, 0],\n//       [0, 0, 0, 0],\n//     ],\n//   ) {\n//     if (\n//       initialState.length === 4 &&\n//       initialState.every((row) => row.length === 4)\n//     ) {\n//       this.initialState = initialState;\n//       this.restart();\n//     } else {\n//       throw new Error('Initial state is not valid!');\n//     }\n//   }\n\n//   moveLeft() {\n//     if (this.status === 'playing') {\n//       const result = this.moveTiles(true, false);\n\n//       if (this.isStateDifferent(result.state)) {\n//         this.updateGame(result);\n//       }\n//     }\n//   }\n\n//   moveRight() {\n//     if (this.status === 'playing') {\n//       const result = this.moveTiles(true, true);\n\n//       if (this.isStateDifferent(result.state)) {\n//         this.updateGame(result);\n//       }\n//     }\n//   }\n\n//   moveUp() {\n//     if (this.status === 'playing') {\n//       const result = this.moveTiles(false, false);\n\n//       if (this.isStateDifferent(result.state)) {\n//         this.updateGame(result);\n//       }\n//     }\n//   }\n\n//   moveDown() {\n//     if (this.status === 'playing') {\n//       const result = this.moveTiles(false, true);\n\n//       if (this.isStateDifferent(result.state)) {\n//         this.updateGame(result);\n//       }\n//     }\n//   }\n\n//   /**\n//    * @returns {number}\n//    */\n//   getScore() {\n//     return this.score;\n//   }\n\n//   /**\n//    * @returns {number[][]}\n//    */\n//   getState() {\n//     return this.state;\n//   }\n\n//   /**\n//    * Returns the current game status.\n//    *\n//    * @returns {string} One of: 'idle', 'playing', 'win', 'lose'\n//    *\n//    * `idle` - the game has not started yet (the initial state);\n//    * `playing` - the game is in progress;\n//    * `win` - the game is won;\n//    * `lose` - the game is lost\n//    */\n//   getStatus() {\n//     return this.status;\n//   }\n\n//   /**\n//    * Starts the game.\n//    */\n//   start() {\n//     this.restart();\n//     this.status = 'playing';\n\n//     this.putNewNumber();\n//     this.putNewNumber();\n//   }\n\n//   /**\n//    * Resets the game.\n//    */\n//   restart() {\n//     this.state = this.cloneState(this.initialState);\n//     this.score = 0;\n//     this.status = 'idle';\n//     this.firstMoveMade = false;\n//   }\n\n//   // Add your own methods here\n//   cloneState(state) {\n//     const newState = [];\n\n//     for (let row = 0; row < state.length; row++) {\n//       newState.push([...state[row]]);\n//     }\n\n//     return newState;\n//   }\n\n//   isStateDifferent(newState) {\n//     for (let row = 0; row < this.state.length; row++) {\n//       for (let column = 0; column < this.state[row].length; column++) {\n//         if (this.state[row][column] !== newState[row][column]) {\n//           return true;\n//         }\n//       }\n//     }\n\n//     return false;\n//   }\n\n//   updateGame(result) {\n//     this.state = result.state;\n//     this.score += result.score;\n//     this.firstMoveMade = true;\n//     this.putNewNumber();\n\n//     if (this.isGameOver()) {\n//       this.status = 'lose';\n//     } else if (this.isGameWon()) {\n//       this.status = 'win';\n//     }\n//   }\n\n//   getFirstMoveMade() {\n//     return this.firstMoveMade;\n//   }\n\n//   getAvailableCell() {\n//     const cell = [];\n\n//     this.state.forEach((row, y) => {\n//       row.forEach((number, x) => {\n//         if (!number) {\n//           cell.push({ x, y });\n//         }\n//       });\n//     });\n\n//     return cell;\n//   }\n\n//   getRandomElement(arr) {\n//     const randomIndex = Math.floor(Math.random() * arr.length);\n\n//     return arr[randomIndex];\n//   }\n\n//   generateNumber() {\n//     return Math.floor(Math.random() * 10) === 0 ? 4 : 2;\n//   }\n\n//   putNewNumber() {\n//     const availableCell = this.getAvailableCell();\n//     const randomCell = this.getRandomElement(availableCell);\n\n//     this.state[randomCell.y][randomCell.x] = this.generateNumber();\n//   }\n\n//   isGameOver() {\n//     if (this.getAvailableCell().length === 0) {\n//       const directions = [\n//         { horizontal: false, forward: false },\n//         { horizontal: true, forward: true },\n//         { horizontal: false, forward: true },\n//         { horizontal: true, forward: false },\n//       ];\n\n//       return directions.every(({ horizontal, forward }) => {\n//         const newState = this.moveTiles(horizontal, forward).state;\n\n//         return this.isStateDifferent(newState);\n//       });\n//     }\n\n//     return false;\n//   }\n\n//   isGameWon() {\n//     return this.state.flat().includes(2048);\n//   }\n\n//   getCellCoords(horizontal, firstCoord, position) {\n//     return horizontal\n//       ? { row: firstCoord, column: position }\n//       : { row: position, column: firstCoord };\n//   }\n\n//   moveTiles(horizontal, forward, addScore) {\n//     const state = this.cloneState(this.state);\n//     let score = 0;\n\n//     const rowLength = state[0].length;\n//     const columnLength = state.length;\n//     let firstCoordLength;\n//     let secondCoordLength;\n\n//     if (horizontal) {\n//       firstCoordLength = columnLength;\n//       secondCoordLength = rowLength;\n//     } else {\n//       firstCoordLength = rowLength;\n//       secondCoordLength = columnLength;\n//     }\n\n//     let initialSecondCoord;\n//     let startOfStripe;\n//     let endOfStirpe;\n//     let step;\n\n//     if (forward) {\n//       initialSecondCoord = secondCoordLength - 2;\n//       startOfStripe = -1;\n//       endOfStirpe = secondCoordLength;\n//       step = 1;\n//     } else {\n//       initialSecondCoord = 1;\n//       startOfStripe = secondCoordLength;\n//       endOfStirpe = -1;\n//       step = -1;\n//     }\n\n//     for (let firstCoord = 0; firstCoord < firstCoordLength; firstCoord++) {\n//       const mergedInStripe = Array(secondCoordLength).fill(false);\n\n//       for (\n//         let secondCoord = initialSecondCoord;\n//         secondCoord !== startOfStripe;\n//         secondCoord -= step\n//       ) {\n//         let merged = false;\n//         let position = secondCoord;\n\n//         let currentCellCoords = this.getCellCoords(\n//           horizontal,\n//           firstCoord,\n//           position,\n//         );\n//         let nextCellCoords = this.getCellCoords(\n//           horizontal,\n//           firstCoord,\n//           position + step,\n//         );\n\n//         while (\n//           position + step !== endOfStirpe &&\n//           (state[nextCellCoords.row][nextCellCoords.column] === 0 ||\n//             (state[nextCellCoords.row][nextCellCoords.column] ===\n//               state[currentCellCoords.row][currentCellCoords.column] &&\n//               !mergedInStripe[position + step] &&\n//               !merged))\n//         ) {\n//           if (state[nextCellCoords.row][nextCellCoords.column] > 0) {\n//             merged = true;\n//             score += state[nextCellCoords.row][nextCellCoords.column] * 2;\n//           }\n\n//           state[nextCellCoords.row][nextCellCoords.column] +=\n//             state[currentCellCoords.row][currentCellCoords.column];\n//           state[currentCellCoords.row][currentCellCoords.column] = 0;\n//           position += step;\n\n//           currentCellCoords = this.getCellCoords(\n//             horizontal,\n//             firstCoord,\n//             position,\n//           );\n\n//           nextCellCoords = this.getCellCoords(\n//             horizontal,\n//             firstCoord,\n//             position + step,\n//           );\n//         }\n\n//         if (merged) {\n//           mergedInStripe[position] = true;\n//         }\n//       }\n//     }\n\n//     return {\n//       state: state,\n//       score: score,\n//     };\n//   }\n// }\n\n// module.exports = Game;\n","'use strict';\n\nconst Game = require('../modules/Game.class');\nconst game = new Game();\n\nfunction updateTable(state) {\n  const fieldRows = document.querySelectorAll('.field-row');\n\n  fieldRows.forEach((rowElement, rowIndex) => {\n    const rowState = state[rowIndex];\n\n    rowState.forEach((cellState, columnIndex) => {\n      const cellElement = rowElement.children[columnIndex];\n\n      cellElement.className = `field-cell field-cell--${cellState}`;\n      cellElement.innerText = cellState > 0 ? cellState : '';\n\n      if (cellState > 0) {\n        cellElement.classList.add('merge');\n\n        setTimeout(() => cellElement.classList.remove('merge'), 600);\n      }\n    });\n  });\n}\n\nfunction updateScore(score) {\n  document.querySelector('.game-score').innerText = score;\n}\n\nfunction updateButton(firstMoveMade) {\n  if (firstMoveMade) {\n    button.className = 'button restart';\n    button.innerText = 'Restart';\n  } else {\n    button.className = 'button start';\n    button.innerText = 'Start';\n  }\n}\n\nfunction updateMessage(gameStatus) {\n  const messageClasses = {\n    idle: 'message-start',\n    win: 'message-win',\n    lose: 'message-lose',\n  };\n\n  document.querySelectorAll('.message').forEach((message) => {\n    message.classList.add('hidden');\n  });\n\n  const messageClass = messageClasses[gameStatus];\n\n  if (messageClass) {\n    document.querySelector(`.${messageClass}`).classList.remove('hidden');\n  }\n}\n\nfunction update() {\n  updateTable(game.getState());\n  updateScore(game.getScore());\n  updateButton(game.getFirstMoveMade());\n  updateMessage(game.getStatus());\n}\n\nconst button = document.querySelector('.button');\n\nbutton.addEventListener('click', () => {\n  switch (button.innerText) {\n    case 'Start':\n      game.start();\n      break;\n    case 'Restart':\n      game.restart();\n  }\n\n  update();\n});\n\ndocument.addEventListener('keydown', (e) => {\n  const actions = {\n    ArrowUp: () => game.moveUp(),\n    ArrowRight: () => game.moveRight(),\n    ArrowDown: () => game.moveDown(),\n    ArrowLeft: () => game.moveLeft(),\n  };\n\n  const action = actions[e.key];\n\n  if (action) {\n    e.preventDefault();\n    action();\n  }\n\n  update();\n});\n"]}